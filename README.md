

## Learn RTOS

### 前言

如何真正掌握 RTOS？自己动手写个RTOS不就行了。

探索吧！Just for Fun.

### 第一阶段目标

对标FreeRTOS源码，参考野火的《FreeRTOS 内核实现与应用开发实战》.

写一个可以跑起来的Demo，模拟FreeRTOS。

#### 1. list.c 带头双向循环链表

链表是通过节点把离散的数据链接成一个表，通过对节点的插入和删除操作从而实现
对数据的存取。

FreeRTOS 中与链表相关的操作均在 list.h和 list.c 这两个文件中实现。

学习方法：

1. 可以先从带头双向循环链表数据结去理解，相对而言比较容易理解，如果对数据结构与指针不熟悉，那要先补课；

2. 带头双向循环链表数据结构的理解要结合对链表的操作一起，两者其实是一体的，为什么是这种结构，只有对这个链表的操作，才能真正理解；

3. 善用Keil的模拟调试，可以一步步跟进观察数据结构中重要变量的数据的变化，验证理解。

数据结构是前人反复实践之后，高度精炼，高度抽象的成果，理解的过程如同逆向破解，在不知道其演化过程的情况下，要能善用工具，通过观察变量在数据结构中的变化来理解其原理，这种方法对于所有数据结构都通用。

#### 2. task.c 任务的定义与任务切换的实现

这个部分我们的**目标**要实现两个变量按照一定的频率轮流的翻转，每个变量对应一个任务。

什么是任务？

在多任务系统中，我们根据功能的不同，把整个系统分割成一个个独立的且无法返回的函数，这个函数我们称为任务。

##### 2.1 创建任务

每个任务都是独立的，互不干扰的，所以要为每个任务都分配独立的栈空间，这个栈空间通常是一个预先定义好的全局数组，也可以是动态分配的一段内存空间，但它们都存在于 RAM 中。

任务的执行是由系统调度的。系统为了顺利的调度任务，为每个任务都额外定义了一个任务控制块，这个任务控制块就相当于任务的身份证，里面存有任务的所有信息，比如任务的栈指针，任务名称，任务的形参等。有了这个任务控制块之后，以后系统对任务的全部操作都可以通过这个任务控制块来实现。

任务的栈，任务的函数实体，任务的控制块最终需要联系起来才能由系统进行统一调度。那么这个联系的工作就由任务创建函数 xTaskCreateStatic()来实现，该函数在 task.c定义。

##### 2.2 实现就绪列表

任务创建好之后，我们需要把任务添加到就绪列表里面，表示任务已经就绪，系统随时可以调度。

就绪列表实际上就是一个 List_t 类型的数组，数组的大小由决定最 大 任 务 优 先 级 的 宏 configMAX_PRIORITIES 决 定 ， configMAX_PRIORITIES 在FreeRTOSConfig.h 中默认定义为 5，最大支持 256 个优先级。数组的下标对应了任务的优先级，同一优先级的任务统一插入到就绪列表的同一条链表中。

任务控制块里面有一个 xStateListItem 成员，数据类型为 ListItem_t，我们将任务插入到就绪列表里面，就是通过将任务控制块的 xStateListItem 这个节点插入到就绪列表中来实现的。如果把就绪列表比作是晾衣架，任务是衣服，那 xStateListItem 就是晾衣架上面的钩
子，每个任务都自带晾衣架钩子，就是为了把自己挂在各种不同的链表中。

##### 2.3 实现调度器

调度器是操作系统的核心，其主要功能就是实现任务的切换，即从就绪列表里面找到优先级最高的任务，然后去执行该任务。从代码上来看，调度器无非也就是由几个全局变量和一些可以实现任务切换的函数组成，全部都在 task.c文件中实现。

###### 2.3.1 启动调度器

调度器的启动由 vTaskStartScheduler()函数来完成。

调用函数 xPortStartScheduler()启动调度器。

配置 PendSV 和 SysTick 的中断优先级为最低。

SysTick 和PendSV 都会涉及到系统调度，系统调度的优先级要低于系统的其它硬件中断优先级，即优先响应系统中的外部硬件中断，所以 SysTick 和 PendSV的中断优先级配置为最低。

调用函数 prvStartFirstTask()启动第一个任务，启动成功后，则不再返回。

prvStartFirstTask()函数用于开始第一个任务，主要做了两个动作，一个是更新 MSP 的值，二是产生 SVC 系统调用，然后去到 SVC 的中断服务函数里面真正切换到第一个任务。

vPortSVCHandler()函数 

SVC 中断要想被成功响应，其函数名必须与向量表注册的名称一致，在启动文件的向量表中，SVC的中断服务函数注册的名称是 SVC_Handler，所以 SVC 中断服务函数的名称我们应该写成 SVC_Handler，但是在 FreeRTOS 中，官方版本写的是 vPortSVCHandler()。

vPortSVCHandler()函数开始真正启动第一个任务，不再返回

当从 SVC 中断服务退出前，通过向 r14 寄存器最后 4 位按位或上0x0D，使得硬件在退出时使用进程堆栈指针 PSP 完成出栈操作并返回后进入任务模式、返回 Thumb 状态。在 SVC 中断服务里面，使用的是 MSP 堆栈指针，是处在ARM 状态。

###### 2.3.2 任务切换

任务切换就是在就绪列表中寻找优先级最高的就绪任务，然后去执行该任务。但是目前我们还不支持优先级，仅实现两个任务轮流切换，任务切换函数 taskYIELD()。

portYIELD 的实现很简单，实际就是将 PendSV 的悬起位置 1，当没有其它中断运行的时候响应 PendSV中断，去执行我们写好的 PendSV中断服务函数，在里面实现任务切换。

xPortPendSVHandler()函数，**PendSV中断服务函数是真正实现任务切换的地方**。

vTaskSwitchContext()函数 ，目前我们还不支持优先级，则手动切换，不是任务 1 就是任务 2。

---

##### 2.4 注意

任务调度涉及CM内核与硬件联系紧密，不仅要有内核的知识，还要懂汇编指令，这里是一个难点。

汇编语言的颗粒度很细，从语句块上理解整体的逻辑与功能，不要陷入细节而被困住。

1. task 与 链表的结合，这一部分理解是重点；

2. TCB任务控制模块的数据结构理解也是一个；

#### 3. 临界段的保护

 临界段用一句话概括就是一段在执行的时候不能被中断的代码段。在 FreeRTOS 里面，这个临界段最常出现的就是对全局变量的操作，全局变量就好像是一个枪把子，谁都可以对他开枪，但是我开枪的时候，你就不能开枪，否则就不知道是谁命中了靶子。可能有人会说我可以在子弹上面做个标记，我说你能不能不要瞎扯淡。

那么什么情况下临界段会被打断？一个是系统调度，还有一个就是外部中断。在FreeRTOS，系统调度，最终也是产生 PendSV中断，在 PendSV Handler里面实现任务的切换，所以还是可以归结为中断。既然这样，FreeRTOS对临界段的保护最终还是回到对中断的开和关的控制。

在 FreeRTOS 中，对临界段的保护出现在两种场合，一种是在中断场合一种是在非中断场合。
