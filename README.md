## Learn RTOS

### 前言

如何真正掌握 RTOS？自己动手写个RTOS不就行了。

探索吧！Just for Fun.

### 第一阶段目标

对标FreeRTOS源码，参考野火的《FreeRTOS 内核实现与应用开发实战》.

写一个可以跑起来的Demo，模拟FreeRTOS。

#### 1. list.c 带头双向循环链表

链表是通过节点把离散的数据链接成一个表，通过对节点的插入和删除操作从而实现
对数据的存取。

FreeRTOS 中与链表相关的操作均在 list.h和 list.c 这两个文件中实现。

学习方法：

1. 可以先从带头双向循环链表数据结去理解，相对而言比较容易理解，如果对数据结构与指针不熟悉，那要先补课；

2. 带头双向循环链表数据结构的理解要结合对链表的操作一起，两者其实是一体的，为什么是这种结构，只有对这个链表的操作，才能真正理解；

3. 善用Keil的模拟调试，可以一步步跟进观察数据结构中重要变量的数据的变化，验证理解。

数据结构是前人反复实践之后，高度精炼，高度抽象的成果，理解的过程如同逆向破解，在不知道其演化过程的情况下，要能善用工具，通过观察变量在数据结构中的变化来理解其原理，这种方法对于所有数据结构都通用。

#### 2. task.c 任务的定义与任务切换的实现

这个部分我们的**目标**要实现两个变量按照一定的频率轮流的翻转，每个变量对应一个任务。

什么是任务？

在多任务系统中，我们根据功能的不同，把整个系统分割成一个个独立的且无法返回的函数，这个函数我们称为任务。

##### 2.1 创建任务

每个任务都是独立的，互不干扰的，所以要为每个任务都分配独立的栈空间，这个栈空间通常是一个预先定义好的全局数组，也可以是动态分配的一段内存空间，但它们都存在于 RAM 中。

任务的执行是由系统调度的。系统为了顺利的调度任务，为每个任务都额外定义了一个任务控制块，这个任务控制块就相当于任务的身份证，里面存有任务的所有信息，比如任务的栈指针，任务名称，任务的形参等。有了这个任务控制块之后，以后系统对任务的全部操作都可以通过这个任务控制块来实现。

任务的栈，任务的函数实体，任务的控制块最终需要联系起来才能由系统进行统一调度。那么这个联系的工作就由任务创建函数 xTaskCreateStatic()来实现，该函数在 task.c定义。

##### 2.2 实现就绪列表

任务创建好之后，我们需要把任务添加到就绪列表里面，表示任务已经就绪，系统随时可以调度。

就绪列表实际上就是一个 List_t 类型的数组，数组的大小由决定最 大 任 务 优 先 级 的 宏 configMAX_PRIORITIES 决 定 ， configMAX_PRIORITIES 在FreeRTOSConfig.h 中默认定义为 5，最大支持 256 个优先级。数组的下标对应了任务的优先级，同一优先级的任务统一插入到就绪列表的同一条链表中。

任务控制块里面有一个 xStateListItem 成员，数据类型为 ListItem_t，我们将任务插入到就绪列表里面，就是通过将任务控制块的 xStateListItem 这个节点插入到就绪列表中来实现的。如果把就绪列表比作是晾衣架，任务是衣服，那 xStateListItem 就是晾衣架上面的钩
子，每个任务都自带晾衣架钩子，就是为了把自己挂在各种不同的链表中。

##### 2.3 实现调度器

调度器是操作系统的核心，其主要功能就是实现任务的切换，即从就绪列表里面找到优先级最高的任务，然后去执行该任务。从代码上来看，调度器无非也就是由几个全局变量和一些可以实现任务切换的函数组成，全部都在 task.c文件中实现。

###### 2.3.1 启动调度器

调度器的启动由 vTaskStartScheduler()函数来完成。

调用函数 xPortStartScheduler()启动调度器。

配置 PendSV 和 SysTick 的中断优先级为最低。

SysTick 和PendSV 都会涉及到系统调度，系统调度的优先级要低于系统的其它硬件中断优先级，即优先响应系统中的外部硬件中断，所以 SysTick 和 PendSV的中断优先级配置为最低。

调用函数 prvStartFirstTask()启动第一个任务，启动成功后，则不再返回。

prvStartFirstTask()函数用于开始第一个任务，主要做了两个动作，一个是更新 MSP 的值，二是产生 SVC 系统调用，然后去到 SVC 的中断服务函数里面真正切换到第一个任务。

vPortSVCHandler()函数 

SVC 中断要想被成功响应，其函数名必须与向量表注册的名称一致，在启动文件的向量表中，SVC的中断服务函数注册的名称是 SVC_Handler，所以 SVC 中断服务函数的名称我们应该写成 SVC_Handler，但是在 FreeRTOS 中，官方版本写的是 vPortSVCHandler()。

vPortSVCHandler()函数开始真正启动第一个任务，不再返回

当从 SVC 中断服务退出前，通过向 r14 寄存器最后 4 位按位或上0x0D，使得硬件在退出时使用进程堆栈指针 PSP 完成出栈操作并返回后进入任务模式、返回 Thumb 状态。在 SVC 中断服务里面，使用的是 MSP 堆栈指针，是处在ARM 状态。

###### 2.3.2 任务切换

任务切换就是在就绪列表中寻找优先级最高的就绪任务，然后去执行该任务。但是目前我们还不支持优先级，仅实现两个任务轮流切换，任务切换函数 taskYIELD()。

portYIELD 的实现很简单，实际就是将 PendSV 的悬起位置 1，当没有其它中断运行的时候响应 PendSV中断，去执行我们写好的 PendSV中断服务函数，在里面实现任务切换。

xPortPendSVHandler()函数，**PendSV中断服务函数是真正实现任务切换的地方**。

vTaskSwitchContext()函数 ，目前我们还不支持优先级，则手动切换，不是任务 1 就是任务 2。

---

##### - 注意

任务调度涉及CM内核与硬件联系紧密，不仅要有内核的知识，还要懂汇编指令，这里是一个难点。

汇编语言的颗粒度很细，从语句块上理解整体的逻辑与功能，不要陷入细节而被困住。

1. task 与 链表的结合，这一部分理解是重点；

2. TCB任务控制模块的数据结构理解也是一个；

#### 3. 临界段的保护

 临界段用一句话概括就是一段在执行的时候不能被中断的代码段。在 FreeRTOS 里面，这个临界段最常出现的就是对全局变量的操作，全局变量就好像是一个枪把子，谁都可以对他开枪，但是我开枪的时候，你就不能开枪，否则就不知道是谁命中了靶子。可能有人会说我可以在子弹上面做个标记，我说你能不能不要瞎扯淡。

那么什么情况下临界段会被打断？一个是系统调度，还有一个就是外部中断。在FreeRTOS，系统调度，最终也是产生 PendSV中断，在 PendSV Handler里面实现任务的切换，所以还是可以归结为中断。既然这样，FreeRTOS对临界段的保护最终还是回到对中断的开和关的控制。

在 FreeRTOS 中，对临界段的保护出现在两种场合，一种是在中断场合一种是在非中断场合。

#### 4. 空闲任务与阻塞延时的实现

任务体内的延时使用的是软件延时，即还是让 CPU空等来达到延时的效果。使用 RTOS 的很大优势就是榨干 CPU 的性能，永远不能让它闲着，任务如果需要延时也就不能再让 CPU 空等来实现延时的效果。RTOS 中的延时叫阻塞延时，即任务需要延时的时候，任务会放弃 CPU的使用权，CPU可以去干其它的事情，当任务延时时间到，重新获取 CPU使用权，任务继续运行，这样就充分地利用了 CPU的资源，而不是干等着。
当任务需要延时，进入阻塞状态，那 CPU又去干什么事情了？如果没有其它任务可以运行，RTOS 都会为 CPU 创建一个空闲任务，这个时候 CPU 就运行空闲任务。在FreeRTOS中，空闲任务是系统在【启动调度器】的时候创建的优先级最低的任务，空闲任务主体主要是做一些系统内存的清理工作。但是为了简单起见，我们本章实现的空闲任务只是对一个全局变量进行计数。鉴于空闲任务的这种特性，在实际应用中，当系统进入空闲任务的时候，可在空闲任务中让单片机进入休眠或者低功耗等操作。

4.1 实现空闲任务

TCB_t IdleTaskTCB;

4.2 实现阻塞延时

4.2.1 vTaskDelay ()函数

阻塞延时的阻塞是指任务调用该延时函数后，任务会被剥离 CPU 使用权，然后进入阻塞状态，直到延时结束，任务重新获取 CPU 使用权才可以继续运行。在任务阻塞的这段时间，CPU可以去执行其它的任务，如果其它的任务也在延时状态，那么 CPU就将运行空闲任务。

4.2.2  vTaskSwitchContext()函数

调用 tashYIELD()会产生PendSV中断，在PendSV中断服务函数中会调用上下文切换函数 vTaskSwitchContext()，该函数的作用是寻找最高优先级的就绪任务，然后更新 pxCurrentTCB。

4.3 SysTick中断服务函数

在任务上下文切换函数 vTaskSwitchContext ()中，会判断每个任务的任务控制块中的延时成员 xTicksToDelay的值是否为 0，如果为 0就要将对应的任务就绪，如果不为 0就继续延时。如果一个任务要延时，一开始 xTicksToDelay 肯定不为 0，当 xTicksToDelay 变为0 的时候表示延时结束，那么 xTicksToDelay 是以什么周期在递减？在哪里递减？在FreeRTOS 中，这个周期由 SysTick 中断提供，操作系统里面的最小的时间单位就是SysTick 的中断周期，我们称之为一个 tick，SysTick 中断服务函数在 port.c 中实现。

4.3.1 xTaskIncrementTick()函数

更新系统时基.

4.4 SysTick初始化函数

SysTick 的中断服务函数要想被顺利执行，则 SysTick 必须先初始化。    

    - vPortSetupTimerInterrupt()函数.

 SysTick 初 始 化 函 数 vPortSetupTimerInterrupt() ， 在xPortStartScheduler()中被调用.

- 系统时钟的大小，因为目前是软件仿真，需要配置成与
  system_ARMCM3.c文件中的 SYSTEM_CLOCK的一样，即等于 25M。如果有具体的硬件，则配置成与硬件的系统时钟一样。

- SysTick 每秒中断多少次，目前配置为 100，即每 10ms中断一次。

##### - 注意

这部分与内核相关的知识比较多，TaskDelay() 与SysTick部分，在多次模拟运行之后，再结合内核部分的知识，相互印证，这里是一个重点。

#### 5. 支持多优先级

现在开始，任务中我们开始加入优先级的功能。在 FreeRTOS 中，数字优先级越小，逻辑优先级也越小，这与隔壁的 RT-Thread和 μC/OS 刚好相反。
